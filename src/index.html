<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Duck</title>
    <link rel="stylesheet" href="index.css"/>
</head>
<body>
<div class="wrapper" id="wrapper">
    <img id="duck" class="duck walking-duck" src="assets/ducks/duck.png">
    <audio id="krik" preload="auto" src="krik.mp3"></audio>

    <div class="callout_wrapper callout_walking" id="callout">
        <div class="callout right callout-text" id="callout-text">Just google it!</div>
    </div>

</div>

<!--<script src="./preloadSettings.js"></script>-->
<script>
    let lang = 'en';
    let talkingDuck = true;
    let arrWithTextEng = [
        'Just google it.',
    ]
    let arrWithTextUkr = [
        'Просто загугли.',
    ]
    let ducks = [
        {name: 'simple', src: 'assets/ducks/duck.png'},
        {name: 'realistic', src: 'assets/ducks/duck_PNG5011.png'},
        {name: 'cool', src: 'assets/ducks/83e4a943664a198eb141cd46d6e36b21.png'},
        {name: 'lilalu1', src: 'assets/ducks/lilalu-quietscheente-al-capo-HR.png'},
        {name: 'lilalu2', src: 'assets/ducks/lilalu-quietscheente-barkeeper-rubber-duck-HR_436x436.png'},
        {name: 'paparazzi', src: 'assets/ducks/Paparazzi-Press-Media-Rubber-Duck-BudUSA-4__45420.1576269236.jpg'},
        {name: 'pixel', src: 'assets/ducks/pixel-yellow-duck-vector-21513825.jpg'},
        {name: 'unicorn', src: 'assets/ducks/png_transparent_unicorn_duck_rubber_duck_bath_toy_bridegroom_lilalu.png'},
        {name: 'piracy', src: 'assets/ducks/rubber_duck_piracy_natural_rubber_png_favpng_62gK31QvdbjEGxWBqaLRNJ06c.jpg'}
    ]


    let wrapper = document.getElementById('wrapper')
    let duck = document.getElementById('duck')
    let audio = document.getElementById("krik");
    let calloutText = document.getElementById('callout-text');
    let callout = document.getElementById('callout');
    audio.volume = .5
    wrapper.style.opacity = 1

    duck.addEventListener('click', () => {
        audio.play();
    })

    const {ipcRenderer} = require('electron')

    let setDuckImg = (mood) =>{
        for (let duckItem of ducks) {
            if(mood===duckItem.name){
                duck.src = duckItem.src;
            }
        }
    }

    ipcRenderer.on('save-settings', (event, data) => {
        let settings = JSON.parse(data)
        setDuckImg(settings.mood)

        lang = settings.language;
        setText(settings.language);

        audio.volume = settings.sound / 100
        wrapper.style.opacity = settings.opacity / 100

        talkingDuck = settings.talking;
    })
    callout.style.opacity = '0'

    let showCallout = () => {
        let sizeInt = 0;
        if (callout.style.opacity === '1') {
            callout.style.opacity = '0'
            sizeInt = 300
        } else {
            callout.style.opacity = '1';
            sizeInt = 415
        }
        ipcRenderer.send("show-callout", {size: sizeInt});
    }

    const channelImg = new BroadcastChannel("settingsImg");
    const channelSound = new BroadcastChannel("settingsSound");
    const channelOpacity = new BroadcastChannel("settingsOpacity");
    const channelLang = new BroadcastChannel("settingsLang");
    const channelWalkingDuck = new BroadcastChannel('channelWalkingDuck');
    const channelTalkingDuck = new BroadcastChannel('channelTalkingDuck');

    channelWalkingDuck.onmessage = (event) =>{
        if(event.data){
            duck.className = 'duck walking-duck'
            callout.className = 'callout_wrapper callout_walking'
        }else{
            duck.className = 'duck non-walking'
            callout.className = 'callout_wrapper non-walking'
        }
    }

    channelImg.onmessage = (event) => {
        duck.src = event.data
    }

    channelSound.onmessage = (event) => {
        audio.volume = event.data
        audio.play();
    }

    channelOpacity.onmessage = (event) => {
        wrapper.style.opacity = event.data
    }

    // setText(lang);
    channelLang.onmessage = (event) => {
        lang = event.data;
        setText(event.data);
    }

    channelTalkingDuck.onmessage = (e)=>{
        talkingDuck = e.data;
    }


    const setText = (lang) => {
        console.log(lang)
        lang === 'en' ?
            calloutText.innerHTML = arrWithTextEng[Math.floor(Math.random() * arrWithTextEng.length)]
            :
            calloutText.innerHTML = arrWithTextUkr[Math.floor(Math.random() * arrWithTextUkr.length)];
    }

    // setInterval(() => {
    //     setText(lang)
    // }, 15000)


    setInterval(() => {
        if(talkingDuck){
            setText(lang)
            showCallout(lang)
            setTimeout(()=>{showCallout(lang)},10000)
        }
    }, 1500000)

</script>
<script src="./AgoraRTC_N-4.11.1.js"></script>
<script>
    let rtc = {
        localAudioTrack: null,
        client: null
    };

    let options = {
        // Pass your App ID here.
        appId: "7359e6f4b955495396fa52516e89d795",
        // Set the channel name.
        channel: "Duck",
        // Pass your temp token here.
        token: "0069bd9a3a57fd942aaad83a86b186bc193IAAe+bVlhojCJ9ziXG4zMRuyL5NMd4HSc2hjQNKJ1KOWKHk6uPMAAAAAEAB/xs3WyeyEYgEAAQDJ7IRi",
        // Set the user ID.
        uid: 1
    };

    async function startBasicCall() {
        // Create an AgoraRTCClient object.
        rtc.client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

        // Listen for the "user-published" event, from which you can get an AgoraRTCRemoteUser object.
        rtc.client.on("user-published", async (user, mediaType) => {
            // Subscribe to the remote user when the SDK triggers the "user-published" event
            await rtc.client.subscribe(user, mediaType);
            console.log("subscribe success");

            // If the remote user publishes an audio track.
            if (mediaType === "audio") {
                // Get the RemoteAudioTrack object in the AgoraRTCRemoteUser object.
                const remoteAudioTrack = user.audioTrack;
                // Play the remote audio track.
                remoteAudioTrack.play();
            }

            // Listen for the "user-unpublished" event
            rtc.client.on("user-unpublished", async (user) => {
                // Unsubscribe from the tracks of the remote user.
                await rtc.client.unsubscribe(user);
            });

        });

        window.onload = function () {

            document.getElementById("join").onclick = async function () {
                // Join an RTC channel.
                await rtc.client.join(options.appId, options.channel, options.token, options.uid);
                // Create a local audio track from the audio sampled by a microphone.
                rtc.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                // Publish the local audio tracks to the RTC channel.
                await rtc.client.publish([rtc.localAudioTrack]);

                console.log("publish success!");
            }

            document.getElementById("leave").onclick = async function () {
                // Destroy the local audio track.
                rtc.localAudioTrack.close();

                // Leave the channel.
                await rtc.client.leave();
            }
        }
    }

    startBasicCall()
</script>

</body>

</html>
